#region INotify
        public event PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        protected bool SetField<T>(ref T field, T value,[CallerMemberName] string propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value))
                return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
#endregion

#region Atributos
#endregion

#region Contructores
#endregion

#region Overrides
#endregion

// SetFIeld(ref m_Property, value);


---------------------------------------------------------------------------


public abstract class BindableBase: INotifyPropertyChanged
	{
		public event PropertyChangedEventHandler PropertyChanged;
		protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
		{
			PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		}
		protected virtual bool SetProperty<T>(ref T item, T value,[CallerMemberName] string propertyName = null)
		{
			if (EqualityComparer<T>.Default.Equals(item, value)) return false;
			
			item = value;
			OnPropertyChanged(propertyName);
			return true;
		}
	}

-------------------------------------------------------------------------------

public class RelayCommand : ICommand    
{    
    private Action<object> execute;    
    private Func<object, bool> canExecute;    
     
    public event EventHandler CanExecuteChanged    
    {    
        add { CommandManager.RequerySuggested += value; }    
        remove { CommandManager.RequerySuggested -= value; }    
    }    
     
    public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)    
    {    
        this.execute = execute;    
        this.canExecute = canExecute;    
    }    
     
    public bool CanExecute(object parameter)    
    {    
        return this.canExecute == null || this.canExecute(parameter);    
    }    
     
    public void Execute(object parameter)    
    {    
        this.execute(parameter);    
    }    
}  


-----------------------------------------------------------------------
With this implementation I can specify what I want to execute 
when I create the command, so I don't need to implement a new class
 for each different action I want to take. Then it could be called using 
the following:
---------------------------------------------------
var cmd1 = new RelayCommand(o => { /* do something 1 */ }, o => true);    
var cmd2 = new RelayCommand(o => { /* do something 2 */ }, o => true);   

---------------------------------------------------

The CommandManager.RequerySuggested handles events when something 
in the interface suggests that a requery should happen. 
If your ICommand adds the handlers to it then it will automatically 
update UI elements when the screen executes some actions. 
(For example, lose focus on a TextBox.)
